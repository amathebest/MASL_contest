library(rpart)
library(rpart.plot)
mod1 <- rpart(Y ~ X1 + X2 + X3, control = rpart.control(cp = 0.0, minsplit = 30)) # we say to the procedure to avoid
rpart.plot::prp(mod1)
summary(mod1)# too long - see it on a shorter tree
?rpart.object
mod1$frame
mean((Y[X1<2.2] - mean(Y[X1<2.2]))^2) + mean((Y[X1>=2.2] - mean(Y[X1>=2.2]))^2)
mean((Y[X3==1] - mean(Y[X3==1]))^2) + mean((Y[X3==0] - mean(Y[X3==0]))^2)
rpart.plot::prp(mod1, extra = 1, type = 1)
## PRUNING
mod1$cptable # norice that this values are computed using a 10-fol CV
plotcp(mod1)
# the prooned tree has to be below the h line
abline(v = which.min(mod1$cptable[,4]), col = 'mediumpurple4') # notice trade-off accuracy-interpretability
abline(v = 3, col = 'mediumpurple1') # size 5
abline(v = 6, col = 'mediumpurple3') # size 12
abline(h = aa, col = 'mediumpurple3') # size 12
aa <- min(mod1$cptable[,4])*3.811789
abline(h = aa, col = 'mediumpurple3') # size 12
par(mfrow=c(1,2))
rsq.rpart( mod1) # plot the residual sum of squares
abline(v = mod1$cptable[6,2], col = 'mediumpurple1') # size 7
abline(v = mod1$cptable[which.min(mod1$cptable[,4]),2], col = 'mediumpurple4')
par(mfrow=c(1,1))
par(mfrow=c(1,1))
# rule of the thumb: relerror + xstd < xerror
plot(mod1$cptable[,2], mod1$cptable[,3], type="b", pch=20)
lines(mod1$cptable[,2],mod1$cptable[,3]+ mod1$cptable[,5], col="purple")
lines(mod1$cptable[,2],mod1$cptable[,4], col="maroon")
mod1$cptable[,3]+ mod1$cptable[,5] < mod1$cptable[,4]
mod1$cptable[3:5,]
# 1se rule
which.min(mod1$cptable[,4]+ mod1$cptable[,5])
## Prune the tree: according to the min xerror
mod1.pruned.long <- prune.rpart(mod1, cp = mod1$cptable[which.min(mod1$cptable[,4]),1] )
summary(mod1.pruned.long)
rpart.plot::prp(mod1.pruned.long, extra = 1, type = 1)
mod1.pruned <- prune.rpart(mod1, cp = 0.027)
summary(mod1.pruned)
rpart.plot::prp(mod1.pruned, extra = 1, type = 1)
# extract dummies function
library(rpart.utils)
rpart.lists(mod1.pruned)
rpart.subrules.table(mod1.pruned)
install.packages("rpart.utils")
brary(rpart)
library(MASS)
data(Boston)
head(Boston)
lm.out <- lm(medv ~ ptratio, data = Boston)
plot(medv ~ ptratio, data = Boston)
abline(lm.out, col="red")
fit <- rpart(medv ~ ptratio, data = Boston)
fit.pruned.tree <-prune(fit, cp = 0.05)
plot(fit.pruned.tree)
text(fit.pruned.tree, use.n = TRUE)
fit.pruned.tree
plot(medv ~ ptratio, data = Boston)
plot(fit.pruned.tree)
text(fit.pruned.tree, use.n = TRUE)
y
y
library(gRbase)
library(gRain)
library(Rgraphviz)
#### How to construct a DAG
dag0 <- dag(~b*a,~c*a,~b*c,~d*b,~e*a,~d*e,~f*c,~f*b)
Rgraphviz::plot(dag0, cex.main = 0.5) # note how the script works: ~c * a * b = c depends on both a and b
dag0
edgeList(dag0) # when the class of edges is "oriented", every edge is in the form of <parent> <child>
as.adjMAT(dag0) # adjacency matrix, on rows = parents, on columns = child
# these two functions identify the parents or the children of a specified node
parents("d", dag0)
children("a", dag0)
# moralized graph
ug0 <- moralize(dag0)
iplot(ug0)
# functions to get edges and cliques
edgeList(ug0)
getCliques(ug0)
# check: b ind e?
ancestralSet(c("a"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
# check: b ind e?
ancestralSet(c("c"), dag0)
parents(c("d", "b"), dag0)
library(gRbase)
library(gRain)
library(Rgraphviz)
#### How to construct a DAG
dag0 <- dag(~b*a,~c*a,~b*c,~d*b,~e*a,~d*e,~f*c,~f*b)
Rgraphviz::plot(dag0, cex.main = 0.5) # note how the script works: ~c * a * b = c depends on both a and b
dag0
edgeList(dag0) # when the class of edges is "oriented", every edge is in the form of <parent> <child>
as.adjMAT(dag0) # adjacency matrix, on rows = parents, on columns = child
# these two functions identify the parents or the children of a specified node
parents("d", dag0)
children("a", dag0)
# moralized graph
ug0 <- moralize(dag0)
iplot(ug0)
# functions to get edges and cliques
edgeList(ug0)
getCliques(ug0)
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
iplot(moralize(ancestralGraph(c("b", "e"), dag0))) # --> no
# check: (d,e) ind b | c ?
ancestralSet(c("b", "e", "d", "c"), dag0)
(b, c) ind e
# check: (d,e) ind b | c ?
ancestralSet(c("b", "e", "d", "c"), dag0)
iplot(ancestralGraph(c("b", "e", "d", "c"), dag0))
iplot(moralize(ancestralGraph(c("b", "e", "d", "c"), dag0)))
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
iplot(moralize(ancestralGraph(c("b", "e"), dag0))) # --> no
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
iplot(moralize(ancestralGraph(c("b", "e"), dag0))) # --> no
# check: a ind d
ancestralSet(c("a", "d"), dag0)
iplot(ancestralGraph(c("a", "d"), dag0))
iplot(moralize(ancestralGraph(c("a", "d"), dag0)))
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
iplot(moralize(ancestralGraph(c("b", "e"), dag0))) # --> no
library(gRbase)
library(gRain)
library(Rgraphviz)
#### How to construct a DAG
dag0 <- dag(~b*a,~c*a,~b*c,~d*b,~e*a,~d*e,~f*c,~f*b)
Rgraphviz::plot(dag0, cex.main = 0.5) # note how the script works: ~c * a * b = c depends on both a and b
dag0
edgeList(dag0) # when the class of edges is "oriented", every edge is in the form of <parent> <child>
as.adjMAT(dag0) # adjacency matrix, on rows = parents, on columns = child
# these two functions identify the parents or the children of a specified node
parents("d", dag0)
children("a", dag0)
# moralized graph
ug0 <- moralize(dag0)
iplot(ug0)
# functions to get edges and cliques
edgeList(ug0)
getCliques(ug0)
# check: b ind e?
ancestralSet(c("b", "e"), dag0)
iplot(ancestralGraph(c("b", "e"), dag0))
iplot(moralize(ancestralGraph(c("b", "e"), dag0))) # --> no
######################  CLASSIFICATION TREES
library(rpart)
par(mfrow = c(1,1))
data(kyphosis)
head(kyphosis)
fit1 <- rpart(Kyphosis ~ ., data = kyphosis,
parms=list(split = "information"))
fit1
summary(fit1)
plot(fit1)
rpart.plot::rpart.plot(fit1)
install.packages("randomForest")
require(randomForest)
require(MASS)
set.seed(101)
dim(Boston)
train=sample(1:nrow(Boston),300)
?Boston
rf.boston = randomForest(medv~. ,data = Boston, subset = train)
rf.boston
.err=double(13)
test.err=double(13)
for(mtry in 1:13){
fit=randomForest(medv~.,data=Boston,subset=train,mtry=mtry,ntree=400)
oob.err[mtry]=fit$mse[400]
pred=predict(fit,Boston[-train,])
test.err[mtry]=with(Boston[-train,],mean((medv-pred)^2))
cat(mtry," ")
}
oob.err=double(13)
test.err=double(13)
for(mtry in 1:13){
fit=randomForest(medv~.,data=Boston,subset=train,mtry=mtry,ntree=400)
oob.err[mtry]=fit$mse[400]
pred=predict(fit,Boston[-train,])
test.err[mtry]=with(Boston[-train,],mean((medv-pred)^2))
cat(mtry," ")
}
matplot(1:mtry,cbind(test.err,oob.err),pch=19,col=c("red","blue"),type="b",ylab="Mean Squared Error")
legend("topright",legend=c("OOB","Test"),pch=19,col=c("red","blue"))
require(gbm)
boost.boston=gbm(medv~.,data=Boston[train,],distribution="gaussian",n.trees=10000,shrinkage=0.01,interaction.depth=4)
install.packages("gbm")
require(gbm)
boost.boston=gbm(medv~.,data=Boston[train,],distribution="gaussian",n.trees=10000,shrinkage=0.01,interaction.depth=4)
summary(boost.boston)
##########################################
# BART
##########################################
rm(list=ls())
dyn.load('/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/jre/lib/server/libjvm.dylib')
options(java.parameters="-Xmx5000m") # must be set initially
library(bartMachine)
install.packages("bartMachine")
set_bart_machine_num_cores(4)
################# data marks
library(ggm)
data(marks)
S <- var(marks) # var/cov
library(gRbase)
library(gRain)
library(Rgraphviz)
head(marks)
stima <- fitConGraph(UG(~ mechanics*vectors*algebra+algebra*analysis*statistics), S, n=88)
stima
round(solve(stima$Shat), 4)
round(correlations(stima$Shat), 4)
iplot(und.g)
und.g <-ug(~ mechanics:vectors:algebra, ~ algebra:analysis:statistics) # undirected butterfly graph
iplot(und.g)
PC <- parcor(var(marks))
#### esempio dati marks
library(ggm)
data(marks)
pairs(marks, panel=panel.smooth)
PC <- parcor(var(marks))
round(PC,3) # lowest correlations are between (analysis, statistics) and (mechanics, vector)
round(cor(marks),3)
round(correlations(marks),3) # sottotriangolare = corr; sovratiangolare=pcor
# Computes the partial correlation between the first two variables given the other variables in a set.
pcor(c("algebra", "analysis", "statistics"), var(marks))
parcor(var(marks[,3:5]))
pcor(c("vectors", "statistics", "algebra"), var(marks))
pcor(c("vectors", "statistics", "analysis"), var(marks))
parcor(var(marks[,c(2,3,5)]))
# model selection from a complete graph
pcor(c(1,5,2,3,4), var(marks))
pcor.test(pcor(c(1,5,2,3,4), var(marks)), 3, n=88) # this gives a p-value of 0.82 and this means that there is no edge between 1 and 5
pcor.test(pcor(c(1,4,2,3,5), var(marks)), 3, n=88) # this gives a p-value of 0.98 and this means that there is no edge between 1 and 4
pcor.test(pcor(c(2,4,1,3,5), var(marks)), 3, n=88) # this gives a p-value of 0.48 and this means that there is no edge between 2 and 4
pcor.test(pcor(c(2,5,1,3,4), var(marks)), 3, n=88) # this gives a p-value of 0.85 and this means that there is no edge between 2 and 5
# SINful procedure
# attenzione : il metodo seguente richiederebbe n grande
library(SIN)
round(fisherz(cor(marks)), 4) # Fisher's z transformation of the correlation matrix
round(fisherz(parcor(var(marks))), 4)
pvals <- sinUG(var(marks), n=88, holm=T) # sinful procedure that gives the pvalues relative to the corresponding test on the edge
pvals # very high p-values on the lower correlations
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.05, col = "red")
abline(h = 0.2, col = "blue")
# two different graphs obtained by setting different thresholds of alpha
getgraph(pvals, alpha=0.05, type="UG")
drawGraph(getgraph(pvals, alpha=0.05, type="UG"))
getgraph(pvals, alpha=0.2, type="UG")
drawGraph(getgraph(pvals, alpha=0.20, type="UG"))
library(SIN)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
data <- read.table("esami_matem.txt", header = FALSE, sep = "", dec = ".")
data
head(data)
data <- read.table("esami_matem.txt", header = TRUE, sep = " ")
head(data)
round(fisherz(cor(data)), 4) # Fisher's z transformation of the correlation matrix
round(fisherz(parcor(var(data))), 4)
data <- read.table("esami_matem.txt", header = TRUE, sep = " ")
data$Anno <- NULL
round(fisherz(cor(data)), 4) # Fisher's z transformation of the correlation matrix
# sinful procedure that gives the pvalues relative to the corresponding test on the edge
pvals <- sinUG(var(data), n=88, holm=T)
pvals
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.05, col = "red")
abline(h = 0.2, col = "blue")
abline(h = 0.3, col = "blue")
getgraph(pvals, alpha=0.3, type="UG")
drawGraph(getgraph(pvals, alpha=0.20, type="UG"))
getgraph(pvals, alpha=0.5, type="UG")
drawGraph(getgraph(pvals, alpha=0.5, type="UG"))
#### dati mtcars
data(mtcars)
?mtcars
mtcars
dim(mtcars)
tail(mtcars)
summary(mtcars)
X <- mtcars[, c(1,3:7)]
head(mtcars)
round(parcor(var(X)))
pvals <- sinUG(cor(X), n = nrow(X), holm = T) # sinful procedure using the correlation matrix
plotUGpvalues(pvals, legend = F)
abline(h = 0.05, col = "red")
edge.matr <- getgraph(pvals, alpha=0.05, type="UG")
edge.matr
drawGraph(edge.matr)
edge.matr <- getgraph(pvals, alpha=0.6, type="UG")
edge.matr
data <- read.table("esami_matem.txt", header = TRUE, sep = " ")
data$Anno <- NULL
round(fisherz(cor(data)), 4) # Fisher's z transformation of the correlation matrix
# sinful procedure that gives the pvalues relative to the corresponding test on the edge
pvals <- sinUG(var(data), n=88, holm=T)
pvals # very high p-values on the lower correlations
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.05, col = "red")
abline(h = 0.3, col = "blue")
# two different graphs obtained by setting different thresholds of alpha
getgraph(pvals, alpha=0.05, type="UG")
drawGraph(getgraph(pvals, alpha=0.05, type="UG"))
getgraph(pvals, alpha=0.5, type="UG")
drawGraph(getgraph(pvals, alpha=0.5, type="UG"))
cor(data)
# sinful procedure that gives the pvalues relative to the corresponding test on the edge
pvals <- sinUG(var(data), n = nrow(data), holm=T)
pvals # very high p-values on the lower correlations
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.05, col = "red")
abline(h = 0.3, col = "blue")
# two different graphs obtained by setting different thresholds of alpha
getgraph(pvals, alpha=0.05, type="UG")
drawGraph(getgraph(pvals, alpha=0.05, type="UG"))
getgraph(pvals, alpha=0.5, type="UG")
drawGraph(getgraph(pvals, alpha=0.5, type="UG"))
getgraph(pvals, alpha=0.2, type="UG")
drawGraph(getgraph(pvals, alpha=0.2, type="UG"))
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.05, col = "red")
abline(h = 0.3, col = "blue")
getgraph(pvals, alpha=0.35, type="UG")
drawGraph(getgraph(pvals, alpha=0.35, type="UG"))
data <- read.table("esami_matem.txt", header = TRUE, sep = " ")
data$Anno <- NULL
# sinful procedure that gives the p-values relative to the corresponding test on the edge
pvals <- sinUG(var(data), n = nrow(data), holm=T)
pvals # this shows very high p-values on the lower correlations and low p-values on high correlations
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.3, col = "blue")
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = 0.35, col = "blue")
getgraph(pvals, alpha=0.35, type="UG")
drawGraph(getgraph(pvals, alpha=0.35, type="UG"))
# plotting the p-values of the tests for each edge
alpha_value = 0.20
plotUGpvalues(pvals, legend = F) # displays each edge with the corresponding p-value
abline(h = alpha_value, col = "blue")
# plotting the obtained graph with the chosen value of alpha
getgraph(pvals, alpha = alpha_value, type="UG")
drawGraph(getgraph(pvals, alpha = alpha_value, type="UG"))
# plotting the obtained graph with the chosen value of alpha
getgraph(pvals, alpha = alpha_value, type="UG")
# plotting the obtained graph with the chosen value of alpha
getgraph(pvals, alpha = alpha_value, type="UG")[0,1]
# plotting the obtained graph with the chosen value of alpha
getgraph(pvals, alpha = alpha_value, type="UG")[0,4]
# plotting the obtained graph with the chosen value of alpha
getgraph(pvals, alpha = alpha_value, type="UG")[1,4]
# obtaining the graph definition that will be used to create the graph with my package
for (i in nrow(adj_mat)) {
for (j in nrow(adj_mat)) {
if (adj_mat[j,i] == 1) {
print(j, i)
}
}
}
adj_mat <- getgraph(pvals, alpha = alpha_value, type="UG")
dim(adj_mat)
nrow(adj_mat)
for (i in nrow(adj_mat)) {
for (j in nrow(adj_mat)) {
if (adj_mat[j,i] == 1) {
print(j, i)
}
}
}
adj_mat[1,1]
adj_mat[1,2]
adj_mat$
dd
adj_mat
names(adj_mat)
typeof(adj_mat)
rownames(adj_mat)
names <- rownames(adj_mat)
for (i in nrow(adj_mat)) {
for (j in nrow(adj_mat)) {
if (adj_mat[j,i] == 1) {
print(names[j])
print(names[i])
}
}
}
names <- rownames(adj_mat)
for (i in nrow(adj_mat)) {
for (j in nrow(adj_mat)) {
if (adj_mat[i,j] == 1) {
print(names[j])
print(names[i])
}
}
}
for (i in nrow(adj_mat)) {
for (j in nrow(adj_mat)) {
print(adj_mat[i,j])
}
}
for (i in 1:nrow(adj_mat)) {
for (j in 1:nrow(adj_mat)) {
print(adj_mat[i,j])
}
}
for (i in 1:nrow(adj_mat)) {
for (j in 1:nrow(adj_mat)) {
if (adj_mat[i,j] == 1) {
print(names[j])
print(names[i])
}
}
}
adj_mat
for (i in 1:nrow(adj_mat)) {
for (j in 1:nrow(adj_mat)) {
if (adj_mat[i,j] == 1) {
print(names[i])
print(names[j])
}
}
}
definition <- ""
paste(definition, "Analisi", "Geometria", sep = "-")
names <- rownames(adj_mat)
definition <- ""
for (i in 1:nrow(adj_mat)) {
for (j in 1:nrow(adj_mat)) {
if (adj_mat[i,j] == 1) {
new_edge <- paste(names[i], names[j], sep = "-")
definition <- paste(definition, new_edge, sep = ",")
}
}
}
definition
definition[1]
definition[,1]
definition[1,]
definition[:1]
definition[:-1]
definition[::-1]
definition[[1]]
# adjacency matrix of the obtained graph
adj_mat <- getgraph(pvals, alpha = alpha_value, type="UG")
adj_mat
# plotting the obtained graph with the chosen value of alpha
drawGraph(getgraph(pvals, alpha = alpha_value, type="UG"))
adj_mat[Algebra, Algebra] = 1
adj_mat["Algebra", "Algebra"] = 1
adj_mat
adj_mat["Algebra", "Algebra"] = 0
# Adjacency matrix of the obtained graph
adj_mat <- getgraph(pvals, alpha = alpha_value, type="UG")
# Plotting the obtained graph with the chosen value of alpha
drawGraph(getgraph(pvals, alpha = alpha_value, type="UG"))
# Analysis:
# We can assume that the first course (like Analysis 1) and the second one (like Analysis 2) are linked by
# an asymmetrical relationship, from the first to the second. For this reason we remove the edge pointing
# from the second to the first:
adj_mat["Analisi2", "Analisi1"] = 0
# The same approach is applied to the other courses:
adj_mat["Fisica2", "Fisica1"] = 0
adj_mat["Geometria2", "Geometria1"] = 0
adj_mat
head(data)
# Adjacency matrix of the obtained graph
adj_mat <- getgraph(pvals, alpha = alpha_value, type="UG")
# Plotting the obtained graph with the chosen value of alpha
drawGraph(getgraph(pvals, alpha = alpha_value, type="UG"))
# Analysis:
# We can assume that the first course (like Analysis 1) and the second one (like Analysis 2) are linked by
# an asymmetrical relationship, from the first to the second. For this reason we remove the edge pointing
# from the second to the first:
adj_mat["Analisi2", "Analisi1"] = 0
# The same approach is applied to the other courses:
adj_mat["Fisica2", "Fisica1"] = 0
adj_mat["Geometria2", "Geometria1"] = 0
# For the rest, in order to build a directed graph, we assume an ordering of the courses. This means that
# we decide which direction has a specific edge between two variables:
adj_mat["Geometria2", "Analisi2"] = 0
# For example, we can also assume that it's possible that Algebra gives proficiency on the exam Fisica1.
# For this reason we can direct the edge between Algebra and Fisica1 to be from Algebra and Fisica1, deleting
# the other direction:
adj_mat["Fisica1", "Algebra"] = 0
# By exploiting the same principle, we can assume an ordering also between Algebra and Geometria1:
adj_mat["Geometria1", "Algebra"] = 0
# Finally we direct two more edges with an arbitrary order:
adj_mat["Geometria2", "Analisi2"] = 0
adj_mat["MecRaz", "Geometria2"] = 0
# Obtaining the graph definition that will be used to create the graph with my package
names <- rownames(adj_mat)
definition <- ""
for (i in 1:nrow(adj_mat)) {
for (j in 1:nrow(adj_mat)) {
if (adj_mat[i,j] == 1) {
new_edge <- paste(names[i], names[j], sep = "-")
definition <- paste(definition, new_edge, sep = ",")
}
}
}
definition
